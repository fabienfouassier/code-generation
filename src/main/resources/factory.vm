## common substitutions without date and user

#set ($package = $options.getPackage())
#set ($factoryClass = $options.getFactoryClassName())
#set ($factoryPackage = $options.getFactoryPackage())
#set ($factoryExtraImport = $options.getExtraFactoryImport())
#set ($ImplementationExtraImport = $options.getExtraImplementationImport())

package ${factoryPackage};

import ${package}.impl.*;

${factoryExtraImport}

import java.util.Collection;

import org.protege.owl.codegeneration.CodeGenerationFactory;
import org.protege.owl.codegeneration.WrappedIndividual;
import org.protege.owl.codegeneration.impl.FactoryHelper;
import org.protege.owl.codegeneration.impl.ProtegeJavaMapping;
import org.protege.owl.codegeneration.inference.CodeGenerationInference;
import org.protege.owl.codegeneration.inference.SimpleInference;

import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyStorageException;

/**
 * A class that serves as the entry point to the generated code providing access
 * to existing individuals in the ontology and the ability to create new individuals in the ontology.<p>
 * 
 * Generated by Protege (http://protege.stanford.edu).<br>
 * Source Class: ${factoryClass}<br>
 * @version generated on ${date} by ${user}
 */
public class ${factoryClass} implements CodeGenerationFactory {
    private OWLOntology ontology;
    private ProtegeJavaMapping javaMapping = new ProtegeJavaMapping();
    private FactoryHelper delegate;
    private CodeGenerationInference inference;

    public ${factoryClass}(OWLOntology ontology) {
	    this(ontology, new SimpleInference(ontology));
    }
    
    public ${factoryClass}(OWLOntology ontology, CodeGenerationInference inference) {
        this.ontology = ontology;
        this.inference = inference;
        javaMapping.initialize(ontology, inference);
        delegate = new FactoryHelper(ontology, inference);
    }

    public OWLOntology getOwlOntology() {
        return ontology;
    }
    
    public void saveOwlOntology() throws OWLOntologyStorageException {
        ontology.getOWLOntologyManager().saveOntology(ontology);
    }
    
    public void flushOwlReasoner() {
        delegate.flushOwlReasoner();
    }
    
    public boolean canAs(WrappedIndividual resource, Class<? extends WrappedIndividual> javaInterface) {
    	return javaMapping.canAs(resource, javaInterface);
    }
    
    public  <X extends WrappedIndividual> X as(WrappedIndividual resource, Class<? extends X> javaInterface) {
    	return javaMapping.as(resource, javaInterface);
    }
    
    public Class<?> getJavaInterfaceFromOwlClass(OWLClass cls) {
        return javaMapping.getJavaInterfaceFromOwlClass(cls);
    }
    
    public OWLClass getOwlClassFromJavaInterface(Class<?> javaInterface) {
	    return javaMapping.getOwlClassFromJavaInterface(javaInterface);
    }
    
    public CodeGenerationInference getInference() {
        return inference;
    }

 
    
    #foreach (${class} in ${root.getOwlClasses()})
    
	    /* ***************************************************
	     * Class ${class.IRI}
	     */
	     
	     #set ($interfaceName = $renamer.getInterfaceName())

	    {
	        javaMapping.add("${class.IRI}", ${interfaceName}.class, ${implementationName}.class);
	    }
	
	    /**
	     * Creates an instance of type ${interfaceName}.  Modifies the underlying ontology.
	     */
	    public ${interfaceName} create${interfaceName}(String name) {
			return delegate.createWrappedIndividual(name, Vocabulary.${VocabClass}, ${implementationName}.class);
	    }
	
	    /**
	     * Gets an instance of type ${interfaceName} with the given name.  Does not modify the underlying ontology.
	     * @param name the name of the OWL named individual to be retrieved.
	     */
	    public ${interfaceName} get${interfaceName}(String name) {
			return delegate.getWrappedIndividual(name, Vocabulary.${VocabClass}, ${implementationName}.class);
	    }
	
	    /**
	     * Gets all instances of ${interfaceName} from the ontology.
	     */
	    public Collection<? extends ${interfaceName}> getAll${interfaceName}Instances() {
			return delegate.getWrappedIndividuals(Vocabulary.${VocabClass}, ${implementationName}.class);
	    }

	#end
}
    
    